<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Face Looker (Anim Face)</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: #ffffff;
      color: #000000;
      overflow: hidden; /* prevent scrolling */
      overscroll-behavior: none; /* prevent bounce/refresh */
      touch-action: none; /* disable default touch gestures */
    }

    .center {
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .viewer {
      position: relative;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .sections {
      display: none;
      gap: 8px;
      margin-top: 12px;
      flex-wrap: wrap;
      justify-content: center;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, sans-serif;
    }
    .sections button {
      padding: 6px 10px;
      border-radius: 16px;
      border: 1px solid #ccc;
      background: #fff;
      cursor: pointer;
    }
    .sections button.active {
      background: #000;
      color: #fff;
      border-color: #000;
    }

    canvas#faceCanvas {
      display: block;
      max-width: 50%;
      width: 256px;
      height: auto;
      border-radius: 50%;
      border: 3px solid #cccccc;
      background: #f7f7f7;
    }

    .hint {
      width: 25vw;
      max-width: 256px;
      margin-top: 1rem;
      margin-left: auto;
      margin-right: auto;
      text-align: center;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, sans-serif;
      font-size: 0.9rem;
      color: #444;
    }
    .repo-link {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 8px;
      text-align: center;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, sans-serif;
      font-size: 0.85rem;
      color: #666;
    }
    .repo-link a {
      color: inherit;
      text-decoration: none;
    }
    .repo-link a:hover {
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <div class="center">
    <div class="viewer" id="viewer">
      <canvas id="faceCanvas"></canvas>
      <div class="sections" id="sectionButtons"></div>
      <div class="hint">Move mouse or drag finger to rotate.<br /><br />Double-click to switch expression.</div>
    </div>
  </div>

  <script>
    // This viewer reads anim-face.json produced by optimize.py (saved in the same folder)
    const MANIFEST_URL = "anim-face.json"; // relative to this HTML file

    const canvas = document.getElementById("faceCanvas");
    const ctx = canvas.getContext("2d");

    fetch(MANIFEST_URL)
      .then((r) => r.json())
      .then((manifest) => {
        const STEP_WIDTH = manifest.step;
        const frameWidth = manifest.frameWidth;
        const frameHeight = manifest.frameHeight;
        const columns = manifest.columns;
        const rows = manifest.rows; // not directly needed but useful

        // Sections support: manifest.sections is an array of { name, displayName, startIndex, frameCount }
        let sections = Array.isArray(manifest.sections) ? manifest.sections : [
          { name: "default", displayName: "default", startIndex: 0, frameCount: manifest.frameCount }
        ];
        // Prefer a default section if present; else pick the first
        let currentSectionIndex = sections.findIndex(s => s.displayName === "default" || s.name === "default");
        if (currentSectionIndex === -1) currentSectionIndex = 0;
        let currentSection = sections[currentSectionIndex];
        // Resolve sprite path relative to the manifest URL so assets can live in ../out/
        const manifestBase = new URL(MANIFEST_URL, window.location.href);
        const SPRITE_SRC = new URL(manifest.image, manifestBase).toString();

        const sprite = new Image();
        sprite.src = SPRITE_SRC;
        sprite.decoding = "async";
        sprite.onload = () => {
          // Set canvas internal resolution to frame size for crisp rendering
          canvas.width = frameWidth;
          canvas.height = frameHeight;

          // Draw initial frame (0Â°)
          let currentAngleDeg = 0;
          drawFrame(0);

          // Build section buttons
          const btnWrap = document.getElementById("sectionButtons");
          btnWrap.innerHTML = "";
          function switchToSection(newIndex) {
            currentSectionIndex = ((newIndex % sections.length) + sections.length) % sections.length;
            currentSection = sections[currentSectionIndex];
            [...btnWrap.querySelectorAll("button")].forEach((b, i) => {
              if (i === currentSectionIndex) b.classList.add("active");
              else b.classList.remove("active");
            });
            // Redraw at the last viewed angle for continuity
            drawFrameByAngle(currentAngleDeg);
          }
          sections.forEach((sec, idx) => {
            const btn = document.createElement("button");
            btn.textContent = sec.displayName || sec.name;
            if (idx === currentSectionIndex) btn.classList.add("active");
            btn.addEventListener("click", () => switchToSection(idx));
            btnWrap.appendChild(btn);
          });

          // Double-click on canvas: cycle to next section
          canvas.addEventListener("dblclick", () => switchToSection(currentSectionIndex + 1));

          // Touch double-tap support (for iOS Safari which lacks dblclick on touch)
          let lastTapTime = 0;
          let lastTapX = 0;
          let lastTapY = 0;
          const DOUBLE_TAP_MAX_DELAY = 300; // ms
          const DOUBLE_TAP_MAX_DISTANCE = 30; // px

          function angleFromCenter(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const dx = clientX - centerX;
            const dy = centerY - clientY; // invert Y so positive is up
            let deg = Math.atan2(dy, dx) * (180 / Math.PI); // -180..180, 0=right, 90=up
            if (deg < 0) deg += 360; // 0..360
            return deg;
          }

          function angleToIndex(deg) {
            const snapped = Math.round(deg / STEP_WIDTH) * STEP_WIDTH;
            const normalized = ((snapped % 360) + 360) % 360;
            const idx = Math.floor(normalized / STEP_WIDTH);
            return Math.min((currentSection.frameCount || 0) - 1, Math.max(0, idx));
          }

          function drawFrameByAngle(deg) {
            const idx = angleToIndex(deg);
            drawFrame(idx);
          }

          function drawFrame(index) {
            // Translate section-local index to global atlas index
            const globalIndex = (currentSection.startIndex || 0) + index;
            const col = globalIndex % columns;
            const row = Math.floor(globalIndex / columns);
            const sx = col * frameWidth;
            const sy = row * frameHeight;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(sprite, sx, sy, frameWidth, frameHeight, 0, 0, canvas.width, canvas.height);
          }

          function handlePointer(clientX, clientY) {
            const deg = angleFromCenter(clientX, clientY);
            currentAngleDeg = deg;
            drawFrameByAngle(currentAngleDeg);
          }

          // Whole-page listeners for smooth interaction
          window.addEventListener("mousemove", (e) => handlePointer(e.clientX, e.clientY));
      window.addEventListener(
        "touchstart",
        (e) => {
          if (e.touches && e.touches.length > 0) {
            const t = e.touches[0];
            const now = Date.now();
            const dx = t.clientX - lastTapX;
            const dy = t.clientY - lastTapY;
            const dist = Math.hypot(dx, dy);
            const isDoubleTap = now - lastTapTime < DOUBLE_TAP_MAX_DELAY && dist < DOUBLE_TAP_MAX_DISTANCE;
            lastTapTime = now;
            lastTapX = t.clientX;
            lastTapY = t.clientY;

            e.preventDefault();
            if (isDoubleTap) {
              switchToSection(currentSectionIndex + 1);
              return;
            }
            handlePointer(t.clientX, t.clientY);
          }
        },
        { passive: false }
      );
      window.addEventListener(
        "touchmove",
        (e) => {
          if (e.touches && e.touches.length > 0) {
            e.preventDefault();
            const t = e.touches[0];
            handlePointer(t.clientX, t.clientY);
          }
        },
        { passive: false }
      );
      window.addEventListener(
        "dblclick",
        (e) => {
          e.preventDefault();
          e.stopPropagation();
          switchToSection(currentSectionIndex + 1);
        },
        { passive: false }
      );
        };
      });
  </script>
  <div class="repo-link">
    <a href="https://github.com/alexanderthurn/optimized-face-looker">https://github.com/alexanderthurn/optimized-face-looker</a>
  </div>
</body>
</html>
